#include "../include/board.h"
#include <stdlib.h>
#include <time.h>

/* Helper function to initialize the board */
void GameBoard :: init()
{
    code_rows.reserve(num_rows);
    feedback_rows.reserve(num_rows);

    for (unsigned int idx = 0; idx < pegs_in_row; idx++)
    {
        code_rows.push_back(PegRow(pegs_in_row));
        feedback_rows.push_back(PegRow(pegs_in_row));
    }
}

/* Constructor */
GameBoard :: GameBoard(unsigned int _num_rows, unsigned int _num_pegs):
    num_rows(_num_rows), pegs_in_row(_num_pegs), shield_pegs_row(pegs_in_row)
{

    init();

    colornames[(int)PegColor::RED] = "RED";
    colornames[(int)PegColor::BLUE] = "BLUE";
    colornames[(int)PegColor::YELLOW] = "YELLOW";
    colornames[(int)PegColor::GREEN] = "GREEN";
    colornames[(int)PegColor::WHITE] = "WHITE";
    colornames[(int)PegColor::BLACK] = "BLACK";
    colornames[(int)PegColor::EMPTY] = "EMPTY";

}

/* Returns the string representation of color from code */
string GameBoard :: get_color_name(PegColor clr)
{
    return colornames[(int)clr];
}

/* Get random color from range of colors */
PegColor GameBoard :: get_color_code(int code)
{
    PegColor color = PegColor::EMPTY;

    switch (code)
    {
    case 0:
        color = PegColor::RED;
        break;
    case 1:
        color = PegColor::BLUE;
        break;
    case 2:
        color = PegColor::YELLOW;
        break;
    case 3:
        color = PegColor::GREEN;
        break;
    case 4:
        color = PegColor::WHITE;
        break;
    case 5:
        color = PegColor::BLACK;
        break;
    case 6:
        color = PegColor::EMPTY;
        break;

    default:
        cout<<"Invalid color code";
        exit(0);
    }
    return color;
}

/* Function to generate the random color */
PegColor GameBoard :: get_random_color()
{

    int code = rand() % ( pegs_in_row );

    PegColor color = get_color_code(code);

    return color;
}

/* Get the code pegs row */
vector<Peg>& GameBoard :: get_code_peg_row(unsigned int row_idx)
{
    return code_rows[row_idx].get_pegs_row();
}

/* Get the feedback peg row */
vector<Peg>& GameBoard :: get_feedback_peg_row(unsigned int row_idx)
{
    return feedback_rows[row_idx].get_pegs_row();
}

/* set a shield peg in shield peg row */
bool GameBoard :: set_shield_peg(unsigned int peg_idx, Peg &peg)
{
    shield_pegs_row.set_peg(peg_idx, peg);
    return true;
}

/* Get shield peg at index */
Peg& GameBoard :: get_shield_peg(unsigned int peg_idx)
{
    return shield_pegs_row.get_peg(peg_idx);
}

/* Create code peg for shield */
/* To be used by code maker */
void GameBoard :: create_shield_code()
{
    srand(time(nullptr));
    for (unsigned int idx=0; idx < pegs_in_row; idx++)
    {
        PegColor clr = get_random_color();
        Peg peg(PegType::CODE, clr);
        shield_pegs_row.set_peg(idx, peg);
    }
}

/* Display the shield codes generated by code maker */
void GameBoard :: display_shield_code()
{
    vector<Peg> pegs = shield_pegs_row.get_pegs_row();
    cout<<"Shield Colors: ";
    for(unsigned int idx = 0; idx < pegs.size(); idx++)
    {
        Peg peg = pegs[idx];
        PegColor clr = peg.get_color();
        cout<<get_color_name(clr)<<" ";
    }
    cout<<endl;
}

/* Display the code pegs color in string */
void GameBoard :: display_code_pegs(unsigned int idx)
{
    vector<Peg>  row = get_code_peg_row(idx);
    cout<<"Entered  code pegs are: ";
    for(Peg &peg : row)
    {
        PegColor clr = peg.get_color();
        cout<<setiosflags(ios::left)<<std::setw(6)<<get_color_name(clr)<<" ";
    }
    cout<<endl;
}

/* Display feedback pegs in color */
void GameBoard :: display_feeback_code(unsigned int idx)
{
    vector<Peg>  row = get_feedback_peg_row(idx);
    cout<<"Feedback code pegs are: ";
    for(Peg &peg : row)
    {
        PegColor clr = peg.get_color();
        cout<<setiosflags(ios::left)<<std::setw(6)<<get_color_name(clr)<<" ";
    }
    cout<<endl;
}

/* set code peg in a row of code pegs */
/* To be used by code breaker */
bool GameBoard :: set_code_peg(unsigned int row_idx, unsigned int peg_idx, Peg &peg)
{

    if( row_idx >= code_rows.size())
        return false;

    code_rows[row_idx].set_peg(peg_idx,peg);
    return true;
}

/* Get the code peg */
Peg& GameBoard :: get_code_peg(unsigned int row_idx, unsigned int peg_idx)
{
    return code_rows[row_idx].get_peg(peg_idx);
}

/* Set the feedback peg */
bool GameBoard :: set_feedback_peg(unsigned int row_idx, unsigned int peg_idx, Peg &peg)
{
    if( row_idx >= code_rows.size())
        return false;

    feedback_rows[row_idx].set_peg(peg_idx,peg);
    return true;
}

/* Get the feedback peg */
Peg& GameBoard :: get_feedback_peg(unsigned int row_idx, unsigned int peg_idx)
{
    return feedback_rows[row_idx].get_peg(peg_idx);
}

/* check whether a color exist in shield codes */
bool GameBoard :: check_color_exist_in_shield(PegColor color)
{
    vector<Peg> pegs = shield_pegs_row.get_pegs_row();
    for(unsigned int idx=0; idx < pegs.size(); idx++)
    {
        Peg peg = pegs[idx];

        if(peg.get_color() == color)
            return true;
    }

    return false;
}

/* verify the guessed code made by code breaker */
bool GameBoard :: verify_guess(int attempt_number)
{

    /* Get the code pegs at particular attempt */
    vector<Peg> code_row = get_code_peg_row(attempt_number);
    vector<Peg> shield_row = shield_pegs_row.get_pegs_row();

    for(unsigned int idx = 0; idx < code_row.size(); idx++)
    {
        Peg code_peg = code_row[idx];
        Peg shield_peg = shield_row[idx];

        /* If colors are same at particular position then set feedback as white */
        if( code_peg.get_color() == shield_peg.get_color())
        {
            Peg peg(PegType::FEEDBACK,PegColor::WHITE);
            set_feedback_peg(attempt_number,idx,peg);

        }
        /* If color is present in shield code but not in correct position, set feedback as black */
        else if (check_color_exist_in_shield(code_peg.get_color()))
        {
            Peg peg(PegType::FEEDBACK,PegColor::BLACK);
            set_feedback_peg(attempt_number,idx,peg);
        }
        /* Else set feedback code as Empty */
        else
        {
            Peg peg(PegType::FEEDBACK,PegColor::EMPTY);
            set_feedback_peg(attempt_number,idx,peg);
        }
    }

    unsigned int idx = 0;
    vector<Peg> feedback_row = get_feedback_peg_row(attempt_number);

    /* if all colors are white in feedback code. It means user had guessed all codes correctly */
    for(idx = 0; idx < feedback_row.size(); idx++)
    {
        if (feedback_row[idx].get_color() != PegColor :: WHITE)
            break;
    }

    return idx == shield_row.size();
}
